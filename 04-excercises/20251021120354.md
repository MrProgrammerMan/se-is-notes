---
title: Chapter 1 - Excercises
id: 20251021120410
tags: []
---
# Chapter 1 - Excercises
1. Professional software has to follow strict requirements posed by the customer. This generally involves developing a comprehensive specification, devloping the software itself, iterating and taking feedback, evolving the product to meet future demands, ensuring training and knowledge required to run and maintain the software etc. In this sense, good documentation, training, etc is part of the software as much as the programs themselves.
2. A generic software product only has a theoretical, general customer meant to represent several future concrete customers. In this regard, the specification of the system is up to the developers of the software, rather than an external client. This means that users of the software may have to manage features they don't need or that aren't perectly configured for their needs. Configurable software can alleviate some of this, however it can be bad for the quality of the software if it turns into an ever-configurable "everything"-software. Users of the software will likely rely more on written and general documentation and require more training.
3. Employing proper software engineering methods in the development of software aims to ensure a high quality of product with a low risk of failure. Well built software is easier to maintain and evolve and carries less risk in the form of shortcomings and system failure. Methodologies of software engineering are meant to highten the chance of a high quality product and make missing something important less likely.
4. Software is not only an increasingly important aspect of our everyday lives. It's also increasingly complex and increasingly exposed to attack. Since software is very abstract(and it is designed to abstract away the characteristics of the technologies and hardware, making knowledge of computers unneccessary to use them), it's very difficult to understand unless you work with them. This means that the people that DO work with software have an increased responsibility in maintaining good ethics to protect the people that have to use software. Software can be malicious and defraud, or it can be faulty and cause injury, financial loss, misinformation, etc. This means that the risks of producing bad software are high, making it a priority to consider along with other requirements in software engineering.
5. Game development is a type of development where entertainment is the primary goal. It's also low risk and generally not dangerous in the case of failure. Therefore, a quick and iterative development with lots of customer contact is preferred. On the other hand, developing military systems will require precise requirement specifications and meticuolous attention to detail. In developing these kinds of systems there will also often be external requirements, regulations and laws that mandate certain documentation and guarantess, making a plan based development process more likely to be applicable.
6. However, regardless of video game or missile guiding system, heart rate monitoring or self driving car software, software is meant to do what it's designed for. No software is designed to fail(by _definition_). I.e.: dependebility is a focus of any software. In the same fassion, it is always the users that will actually be affected by the software regardless of the type of software. So requirements management is central. Reuse is important for two reasons; decreased complexity and saving resources. When considering the whole of the millions of software products existing, it is clear that unifying some library or piece of functionality between them greatly standardises, and decomplexifies, them. It's also very wasteful to reinvent the whell, rather than doing something more useful. Of course, it's always a matter of consideration when it is advisable to use some pre-existing solution. Process is important because software is complex. The nature of software is that it is extremely flexible; that's what we've made it to be. Infinite flexibility comes with the opportunity of infinite complexity. Thus, considering the process used in software development can manage the extent of this complexity and ensure some sort of boundry to keep the product maintainable. If the product cannot be maintained, evolved, analysed, etc. _it is bad software_.
7. As software is ever-changing and has to be developed ever-faster, it can be useful to keep rapid communication between different teams that affect the product. You always want to figure out a change in the product as quickly as possible, before you can waste resources developing something you won't end up deploying to users.
8. Software engineering includes some philosophy, ethical considerations, process standard, etc. This are, however, not enforced. Anyone can develop software, and are free to practice "software engineering". This means it is up to individuals and organizations to determine collaboration partners, employers, etc. This can be great, s you don't **need** an expensive degree to practice software development. A degree is, however, a form of guarantee. You know that the person not only has the technical knowledge required to solve the problem, but also the sourrounding theory needed to properly consider the implications and limitations of their work. We have degrees designed to include many topics we deem necessary to be able to call youself a certified software engineer. This does not mean it's necessary to produce good products, but it is a way for an organization to minimize the chance of faulty or malicious software being deployed.
9. There are 8 guiding principles in ACM/IEEE-CS code of ethics:
    1. Public - Public interest can be a vague term. For example, one could argue that developing addictive gambling software designed to pray on addicts of monitary games is unethical as it doesn't serve the public in any way. It only enriches a company by taking from individuals.
    2. Client and employer - Software is developed for the client. The employer specifies the use of the software. It is not for developer to decide against client/employer in what or how software should be developed, as it is not the developer that will use the software in the end. If you hired a carpenter to install oak floor panels, it would be completely inappropriate for the carpenter to decide to use spruce panels; even if it's better. The carpenter may inform the client that there has been reports the oak panels crack after a short period and _advise_ them to choose the spruce. It is, however, the client that will walk on the floor and thus decide in the end. Of course, in extreme cases, the carpenter could for example refuse to endanger the client if asked to install a machine that sprays airborn asbestos into the kitchen.
    3. Product - It's important that software engineers ensure high quality in products. This touches on previously mentioned points. The employer can typically not ensure this themselves; they are realiant on the competence of the software engineers/engineering firm. The firm is expected to deliver, and justify any constraints of shortcomings with valid reasoning(budget constraints, time constraints, etc.). Certain things, like security are not acceptable to compromise on. They take priority over things like budget.
    4. Judgement - A software engineer should be objective and professional in judgement. If asked about a security threat, a developer cannot decide they think no-one will want to attack that specific software, therefore the vulnurability is acceptable.
    5. Management - Leaders and managers are looked up to and have a special responsibility in the shaping of new software engineers with little previous experience(context). A new employee might be unsure of what to report or not in an ethical dilemma. If a manager decides to sweep something under the rug, this can negatively affect all decisions made by that software engineer in future dilemmas.
    6. Profession - Trust in the software profession is required for software as a product and service to be viable in society. As software is so integral, it is vital that we maintain a high reputation of the software engineering field. If hobby grade software was deployed in a professional setting due to mistrust in software engineering as a profession, the effects could be disastrous.
    7. Colleagues - Software engineering is a field where hundreds or thousands of people can be involved in the creation of a piece of software. Everyone needs supportive colleagues and a good work environment. Failing to contribute to this can have negative effects - also on products that further affect million or even billions of people.
    8. Self - If a software engineer fails to learn and promote ethical ways of working, they can negatively affect the business as a whole. In an ever-changing field, we too need to be ever-changing.
10. Building drone systems are a technology that - like all others - can be used for both good and bad. Indeed, vital medicine is often delivered with drones in rural areas. However, recently, drones have been increasingly important for military purposes. This makes it a type of technology that has profound ethical implications to contribute to. Deciding to use ones skills for this is likely accepting that it can contribute to all use cases of drones, including war efforts. They have the potential to change every day life, as they enable types of attack not before seen. That being said, they can also effectivize our societies and reduce carbon footprint.